// StableFluids - A GPU implementation of Jos Stam's Stable Fluids on Unity
// Inspired by https://github.com/keijiro/StableFluids

#pragma kernel AddSource
#pragma kernel GaussSeidel
#pragma kernel Advect
#pragma kernel CreateVelocityField
#pragma kernel ProjectionSetup
#pragma kernel Projection
#pragma kernel ProjectionFinish
#pragma kernel Pyrolysis
// Diffusion - but only on channel 1 (r)
#pragma kernel GaussSeidelChannelOne 
#pragma kernel FuelCombine 

// Common parameter
float Time;
float DeltaTime;
float h;

//Pyrolysis
float FuelDensity; // G channel (gas) per unit of R channel (solid)
float FuelConversionRate; // how much R is coverted into G when we are at MaxPyrolysisTemp?
float MinPyrolysisTemp; // minimum temperature at which pyrolysis takes place
float MaxPyrolysisTemp; // temperature at which we achieve maximum pyrolysis

// Diffusion
float Diff;
float Alpha;
float Beta;

// External source
float2 SourceOrigin;
float SourceStrength;
float SourceDistance; // How far we reach when placing source on an even gradient. 
                      // dist == 0 = SourceStrength. dist >= SourceDistance = 0

// D (density field - smoke)
Texture2D<float2> D_in;
SamplerState samplerD_in;
RWTexture2D<float2> D_out;
SamplerState samplerD_gsbuff;
RWTexture2D<float2> D_gsbuff; // gauss seidel relaxation buffer

// V (velocity field - physical forces)
RWTexture2D<float2> V_in;
SamplerState samplerV_in;

RWTexture2D<float2> V_out;
SamplerState samplerV_out;

// H (height field - for our projection step)
Texture2D<float2> H_in;
SamplerState samplerH_in;
RWTexture2D<float2> H_out;

// FS - fuel (solid)
Texture2D<float2> FS_in;
SamplerState samplerFS_in;
RWTexture2D<float2> FS_out;
// FG - fuel (gaseous)
Texture2D<float2> FG_in;
SamplerState samplerFG_in;
RWTexture2D<float2> FG_out;

RWTexture2D<float2> FSG_out; // both channels

// T - temperature
Texture2D<float2> T_in;
SamplerState samplerT_in;
RWTexture2D<float2> T_out;

//SamplerState samplerH_out;

/*
RWStructuredBuffer<float> temperature;
RWStructuredBuffer<float> solid; // solid fuel - pre-pyrolysis
RWStructuredBuffer<float> gas; // gaseous fuel
*/

// Add-force step
[numthreads(8, 8, 1)]
//[numthreads(1, 1, 1)]
void AddSource(uint2 tid : SV_DispatchThreadID)
{
    uint2 dim;
    D_out.GetDimensions(dim.x, dim.y); // dimensions will be in pixels of screen / render target
    
    // We want to convert from screen space coordinates to texture space coordinates
    
    float2 pos = (tid + 0.5 - dim * 0.5);
    pos.x /= float(dim.x);
    pos.y /= float(dim.y); // normalize based on both axes, not just height which is what the original implementation did
    
    float dist = distance(SourceOrigin, pos);
    
    float amp = max(0, SourceStrength * (1.0 - (dist * SourceDistance)));
    
    // Since we're adding source on top of something,
    // D_out and D_in are probably going to be the same target
    D_out[tid] = D_in[tid] + float2(amp, 0.);
}

// Our diffusion step
[numthreads(8, 8, 1)]
void GaussSeidel(uint2 tid : SV_DispatchThreadID)
{
    D_out[tid] = (D_in[tid] + Alpha * (
        D_gsbuff[tid - int2(1, 0)]  + 
        D_gsbuff[tid + int2(1, 0)] +
        D_gsbuff[tid - int2(0, 1)] +
        D_gsbuff[tid + int2(0, 1)])
    ) * Beta;
}

[numthreads(8, 8, 1)]
void Advect(uint2 tid : SV_DispatchThreadID) {
    uint2 dim;
    D_out.GetDimensions(dim.x, dim.y); // dimensions will be in pixels of screen / render target
    
    int i, j, i0, j0, i1, j1;
    float x, y, s0, t0, s1, t1;
    
    float dt0 = DeltaTime * dim.y;
    
    x = float(tid.x) - dt0 * V_in[tid].r; // r component - x velocity
    y = float(tid.y) - dt0 * V_in[tid].g; // g component - y velocity
    
    if (x<0.5) x=0.5; if (x>float(dim.x)+0.5) x=float(dim.x)+0.5; i0=(int)x; i1=i0+1; 
    if (y<0.5) y=0.5; if (y>float(dim.y)+0.5) y=float(dim.y)+0.5; j0=(int)y; j1=j0+1; 
    s1 = x-i0; s0 = 1.-s1; t1 = y-j0; t0 = 1.-t1;
    
    D_out[tid] = s0*(t0*D_in[int2(i0,j0)] + t1*D_in[int2(i0,j1)]) + 
                s1*(t0*D_in[int2(i1,j0)] + t1*D_in[int2(i1,j1)]);
}


[numthreads(8, 8, 1)]
void CreateVelocityField(uint2 tid : SV_DispatchThreadID) {
    uint2 dim;
    V_in.GetDimensions(dim.x, dim.y); // dimensions will be in pixels of screen / render target
    
    V_in[tid] = float2(tid) / float2(dim);
}

[numthreads(8, 8, 1)]
void ProjectionSetup(uint2 tid : SV_DispatchThreadID) {
    //uint2 dim;
    //V_in.GetDimensions(dim.x, dim.y); // dimensions will be in pixels of screen / render target
    
    //float h = 1.0 / dim.y;
    
    int i = tid.x;
    int j = tid.y;
    
    H_out[tid] = float2(0., -0.5 * h * (V_in[int2(i+1,j)].x - V_in[int2(i-1, j)].x + V_in[int2(i, j+1)].y - V_in[int2(i, j-1)].y));
}

[numthreads(8, 8, 1)]
void Projection(uint2 tid : SV_DispatchThreadID) {
    int i = tid.x;
    int j = tid.y;
    float x = (H_in[int2(i,j)].y+H_in[int2(i-1,j)].x+H_in[int2(i+1,j)].x+H_in[int2(i,j-1)].x+H_in[int2(i,j+1)].x)/4.;
    H_out[tid] = float2(x, H_out[tid].y);
}

[numthreads(8, 8, 1)]
void ProjectionFinish(uint2 tid : SV_DispatchThreadID) {
    //uint2 dim;
    //V_out.GetDimensions(dim.x, dim.y); // dimensions will be in pixels of screen / render target
    //float h = 1.0 / dim.y;
    
    int i = tid.x;
    int j = tid.y;
    
    V_out[tid] -= float2(0.5 * (H_in[int2(i+1, j)].x - H_in[int2(i-1,j)].x) * h,
     0.5 * (H_in[int2(i, j+1)].x - H_in[int2(i,j-1)].x) * h);
}

[numthreads(8, 8, 1)]
void Pyrolysis(uint2 tid : SV_DispatchThreadID) {
    float amountSolidRemoved = min(FS_in[tid], lerp(0., FuelConversionRate, saturate((((T_in[tid] * 10000.) - MinPyrolysisTemp) / MaxPyrolysisTemp))));
    //F_out[tid] = float2(F_in[tid].r - amountSolidRemoved, F_in[tid].g + amountSolidRemoved * FuelDensity);
    FS_out[tid] = FS_in[tid] - amountSolidRemoved;
    FG_out[tid] = FG_out[tid] + amountSolidRemoved * FuelDensity;
}

// Our diffusion step
[numthreads(8, 8, 1)]
void GaussSeidelChannelOne(uint2 tid : SV_DispatchThreadID)
{
     D_out[tid] = float2(D_out[tid].r,
     (D_in[tid].g + Alpha * (
        D_gsbuff[tid - int2(1, 0)].g  + 
        D_gsbuff[tid + int2(1, 0)].g +
        D_gsbuff[tid - int2(0, 1)].g +
        D_gsbuff[tid + int2(0, 1)].g)
    ) * Beta);
}

// Our diffusion step
[numthreads(8, 8, 1)]
void FuelCombine(uint2 tid : SV_DispatchThreadID)
{
    FSG_out[tid] = float2(FS_in[tid].r, FG_in[tid].r);
}